---
layout:     post
title:      DiffPose代码笔记
subtitle:   详解论文与代码对应关系
date:       2024-02-26
author:     CYXYZ
header-img: img/diff-pose.jpg
catalog: true
tags:
    - DiffPose
    - 2D/3D
---


# DiffPose notebook

## 预处理X-ray

通过CT可以得到虚拟X射线图像，称为DRRs（数字重建投影）。为了对真实X射线和CT图像模拟产生的X射线关系进行操作，需要对X射线做预处理转变为DRRs图像。

预处理步骤：

1. 从每个边缘裁剪50像素，以去除由准直器(collimator)引起的影响。

   *准直器是一种医学成像和放射线治疗领域的重要组件。其主要功能是限制放射线束的大小和形状，并将其定向到一个特定的区域。作用有三点：限定成像的空间范围（限定断层层厚）。降低患者的表面辐射剂量。减少进人探测器的散射线。*

2. 反转成像方程以恢复线积分射线图(line integral radiograph)。

   **比尔-朗伯定律：描述透过介质光强衰减的物理定律。**
   \begin{equation}
   I_f[i,j]=I_0\exp(-L[i,j]),
   \end{equation}
   **文章进一步解释了如何通过公式进行反转计算线积分$$L$$**：
   \begin{equation}
   L[i,j]=\log I_0-\log I_f[i,j],
   \end{equation}
   $$I_0$$被近似为$$I[i,j]$$的最大值，假设这个代表一个没有与体积相交就达到探测器平面的射线。

3. 将图像重新归一化到[0, 1]范围内。

注意，文章中提取真实X光数据集的代码是：

```python
specimen = DeepFluoroDataset(
    1,
    filename=filename,
    preprocess=True,  # Set as True to preprocess images
)
processed_xray, _ = specimen[0]
```

上面如果preprocess=True，那么将得到预处理真实X光之后的数据集，而preprocess=False，将得到真实的X光数据集。

若使用DRR来生成数据，文章中对应的代码部分是：

```python
height = 1536 
dx = 0.194
drr = DRR(
    specimen.volume,
    specimen.spacing,
    sdr=specimen.focal_len / 2,
    height=height,
    delx=dx,
    x0=specimen.x0,
    y0=specimen.y0,
    reverse_x_axis=True,
    patch_size=384,
).to(device)
```

设置specimen之后，就能使用这个代码生成DRR对象。使用下面的语句可以得到通过DRR产生的不同姿势的x光图像。

```python
pred_xray = drr(pose.to(device))
```

这样产生的pred_xray和processed_xray仍然有一定差距，因此，可以在生成DRR之前对CT进行预处理，将空气、软组织和骨头进行分割。

使用bone_attenuation_multiplier = 1.0（默认值）会将空气像素的值设为0。 增加bone_attenuation_multiplier会使骨头的密度高于软组织（即增加DRR中的对比度）。

```python
drr = DRR(
    specimen.volume,
    specimen.spacing,
    sdr=specimen.focal_len / 2,
    height=height,
    delx=dx,
    x0=specimen.x0,
    y0=specimen.y0,
    reverse_x_axis=True,
    patch_size=359,
).to(device)

_, pose = specimen[0]
pred_xray = drr(
    pose.to(device),
    bone_attenuation_multiplier=2.5,  # Set the bone attenuation multiplier
)
```

通过如下代码绘制：

```python
plt.figure(constrained_layout=True)
plt.subplot(121)
plt.title("DRR")
plt.imshow(pred_xray.squeeze().cpu().numpy(), cmap="gray")
plt.subplot(122)
plt.title("Processed X-ray")
plt.imshow(processed_xray.squeeze(), cmap="gray")
plt.show()
```

![1](..\img\1.jpg)

这样最后的图片大致为这样。

## 相机姿态

文章使用不同旋转平移的相机姿态SE3来表示相机。在这里，相机的姿态由三个旋转参数和三个平移参数组成。文中提到，这些参数是从独立的正态分布中采样的，这意味着每个参数都是从一个具有足够方差的正态分布中随机选择的，以便捕捉到从等轴中心（isocenter）发生的广泛变化。文章中对应的代码如下：

```python
@beartype
def get_random_offset(batch_size: int, device) -> RigidTransform:
    r1 = torch.distributions.Normal(0, 0.2).sample((batch_size,))
    r2 = torch.distributions.Normal(0, 0.1).sample((batch_size,))
    r3 = torch.distributions.Normal(0, 0.25).sample((batch_size,))
    t1 = torch.distributions.Normal(10, 70).sample((batch_size,))
    t2 = torch.distributions.Normal(250, 90).sample((batch_size,))
    t3 = torch.distributions.Normal(5, 50).sample((batch_size,))
    log_R_vee = torch.stack([r1, r2, r3], dim=1).to(device)
    log_t_vee = torch.stack([t1, t2, t3], dim=1).to(device)
    return convert(
        log_R_vee,
        log_t_vee,
        parameterization="se3_log_map",
    )
```

### 相机的内外参详解

参考[一文带你搞懂相机内参外参(Intrinsics & Extrinsics) - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/389653208)。

讲的蛮清楚的，最终就是：

**内参矩阵：**

相机坐标系与像素坐标系的相互变换。3D <---> 2D 。当然从像素坐标系到图像坐标系与之前做智能车接收到的map数据相同，就是一个是真实世界中的距离，一个是像素世界中的距离，中间有一个分辨率的影响。

**外参矩阵：**

相机坐标系与世界坐标系的相互变换。3D <---> 3D

# fiducials

搞了好久终于能够可视化fiducials了，主要就是利用数据集的get_2d_groundtruth函数，但是由于训练创建的drr图像是256*256的，但是fiducials仍然保持之前1436的尺度不变，因此绘制出来的fidicials在尺度上有一些问题。这时候对fidicials进行下采样把尺度变为256的即可在原先的图片上绘制fiducials。
